[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DE Roadmap",
    "section": "",
    "text": "Data Engineering Road Map\nHello! Iâ€™ve decided to create a repository to share my experience and knowledge in data engineering, with a particular focus on Geospatial Data Engineering, on this website. Iâ€™ll start with the fundamentals, and as I progress to more advanced topics, Iâ€™ll continue adding new chapters.",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Data Engineering Road Map</span>"
    ]
  },
  {
    "objectID": "index.html#agenda",
    "href": "index.html#agenda",
    "title": "DE Roadmap",
    "section": "ðŸ“‹ Agenda",
    "text": "ðŸ“‹ Agenda\n\nTech Fundemental\nAWS Sollution Architechure\nCI/CD ØŒTerraform ØŒAnsible\nDocker Technology\nSQL Language\nApache Spark Sedona\nPrefect & Airflow\nFast API",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Data Engineering Road Map</span>"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "DE Roadmap",
    "section": "ðŸ™‹ License",
    "text": "ðŸ™‹ License\nThis repository uses a dual-licensing approach:\n\nMIT License for all software code\nCreative Commons Attribution 4.0 International (CC BY 4.0) for documentation, data, and non-code content",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Data Engineering Road Map</span>"
    ]
  },
  {
    "objectID": "modules/01.Tech_Fundemental.html",
    "href": "modules/01.Tech_Fundemental.html",
    "title": "Tech Fundemental",
    "section": "",
    "text": "All the information presented here was collected from the Tech Fundamentals course by Adrian Cantrill. I summarized the material to make it easier for myself and others to review it quickly; however, I recommend taking the course itself, as it is free of charge and provides much more detailed information.",
    "crumbs": [
      "Tech Fundemental"
    ]
  },
  {
    "objectID": "modules/012.OSI7_layers.html",
    "href": "modules/012.OSI7_layers.html",
    "title": "OSI 7-Layer Networking Model",
    "section": "",
    "text": "Physical Layer\nThe OSI (Open Systems Interconnection) model is a conceptual framework that describes the communication functions of a telecommunication or computer system. It includes 7 layers which is divided into two layers including Media Layers and Host Layers.\nLetâ€™s imagine, we have two laptops and we want to connect them together. Since both laptops have network interface card, they can be connected using the network cable. We will use the copper network cable to create point-to-point electrical shared medium between these two devices. Physical medium can be copper, Fiber or WiFi.\nPhysical Layer specification define the transmission and reception of raw bit streams between a device and a shared physical medium. Specification means that both laptops have shared understanding of the physical medium.\nIf a device is referred as layer X, it means the device has functionality for layer X and below\nIf there is a more than two devices, it is not possible to connect them using the network cable, instead we can add a device called a HUB. The HUB job is to transmit anything received on any port, to every other port including any errors & collisions.\nCuople of points should be considered about physical layer:",
    "crumbs": [
      "Tech Fundemental",
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>OSI 7-Layer Networking Model</span>"
    ]
  },
  {
    "objectID": "modules/012.OSI7_layers.html#transport-session-layers",
    "href": "modules/012.OSI7_layers.html#transport-session-layers",
    "title": "OSI 7-Layer Networking Model",
    "section": "Transport & Session Layers",
    "text": "Transport & Session Layers\nLayer 4 build on top of the layer 3 (network layer), and it adds two new protocols:\n\nTCP (Transmission Control Protocol): You would pick TCP, when you want reliability, error correction, and ordering of data. It is used for most of the important application lab protocols such as HTTP, HTTPS, SSH, etc. TCP is a connection-oriented protocol meaning that you need to set up a connection between two devices and once set up, it creates a bidirectional channel of communications.\nUDP (Usrer Datagram Protocol): It is faster, because it dose not have the TCP overhead required for the reliable delivery of data. This means that it is less reliable.\n\nBoth of these run on top of IP, and both of them add a collection of features depending on which one of them is used.\nTCP something called segment. A segment is just another container for data like packet and frame. TCP segment are encapsulated within IP pocket. Segments do not have source or destination IP addresses, because they use the IP packets for transit from source to destination. TCP segments add additional capabilities to IP packets including source and destination ports, sequence, acknowledgment etc.\nSource and destination ports which gives the combined TCP/IP protocol the ability to have multiple streams of conversations at the same time between two devices.\nThe sequence number is incremented with each segment thatâ€™s sent and itâ€™s unique. It can be used for error correction, if things need to be re-transmitted, and it can be used to ensure that when IP packets are received, and TCP segments are pulled out, they can be correctly ordered. The sequence number is a way of uniquely identifying a particular segment within a particular connection so the both sides can make observations about it\nThe acknowledgment field is the that one side can indicate that is received up to and including a certain sequence number. Every segment which is transmitted needs to be acknowledged.\n\n\n\n\n\n\nTip\n\n\n\nA stateless firewall would see two things. Outbound and response therefore two rules will be required (OUT & IN). A statefull firewall views the one thing which outbound allowing the outbound implicitly allows the inbound resposne",
    "crumbs": [
      "Tech Fundemental",
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>OSI 7-Layer Networking Model</span>"
    ]
  },
  {
    "objectID": "modules/100.Tips_Tricks.html",
    "href": "modules/100.Tips_Tricks.html",
    "title": "Tips & Tricks",
    "section": "",
    "text": "In this section, I will share some tips and tricks that I have learned from my experience. These tips and tricks are not related to any specific technology, but rather general tips and tricks that I have learned from my experience.",
    "crumbs": [
      "Tips & Tricks"
    ]
  },
  {
    "objectID": "modules/101.GCP.html",
    "href": "modules/101.GCP.html",
    "title": "Configuring a Google Cloud Storage Bucket on a VM",
    "section": "",
    "text": "Install gcsfuse\nThis section is about configuring a Google Cloud Storage Bucket on a VM. This allows the VM to read and write data directly to the bucket. The instructions below assume that you already have access to a VM.\ngcsfuse is a tool that allows you to mount GCS buckets as file systems on Linux and macOS.\nOfficial documentation and installation instructions can be found here: Install or upgrade Cloud Storage FUSE.\nAfter installation, verify it by running:",
    "crumbs": [
      "Tips & Tricks",
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Configuring a Google Cloud Storage Bucket on a VM</span>"
    ]
  },
  {
    "objectID": "modules/101.GCP.html#install-gcsfuse",
    "href": "modules/101.GCP.html#install-gcsfuse",
    "title": "Configuring a Google Cloud Storage Bucket on a VM",
    "section": "",
    "text": "gcsfuse --version",
    "crumbs": [
      "Tips & Tricks",
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Configuring a Google Cloud Storage Bucket on a VM</span>"
    ]
  },
  {
    "objectID": "modules/101.GCP.html#mount-the-storage-bucket",
    "href": "modules/101.GCP.html#mount-the-storage-bucket",
    "title": "Configuring a Google Cloud Storage Bucket on a VM",
    "section": "Mount the Storage Bucket",
    "text": "Mount the Storage Bucket\nCreate a local directory to serve as the mount point:\nmkdir /mnt/embed2social-storage\nAdjust permissions for the directory:\nchmod 777 /mnt/embed2social-storage\nGive all the users to use mounted storage\nvim /etc/fuse.conf #uncomment the user_allow_other\nMount the bucket inside the created directory:\ngcsfuse --implicit-dirs -o allow_other --uid=0 --gid=0 --dir-mode=0775 embed2social-storage /mnt/embed2social-storage/\nVerify the mount:\ndf -h # mounted shoudl be seen in the list\nUnmount the bucket when finished:\nfusermount -u /mnt/embed2social-storage/\n\n\n\n\n\n\nImportant\n\n\n\nThe --implicit-dirs flag allows gcsfuse to handle directories implicitly.\nEnsure that your VM has the necessary permissions (via service account or user credentials) to access the GCS bucket.\n\n\n\n\n\n\n\n\nTip\n\n\n\nAt the moment, only the user who mounted the bucket has permission to read and write data. To allow all users to access the bucket and perform read/write operations, all users must be added to the root group. To do this, follow the steps below:\nsudo su -\nusermode -aG root &lt;username&gt;\nsudo chmod 775 /mnt\n# To ckeck you can act as one of the users and try to read/write the data in bucket\nsudo su - &lt;username&gt;",
    "crumbs": [
      "Tips & Tricks",
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Configuring a Google Cloud Storage Bucket on a VM</span>"
    ]
  }
]